{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hamiltonian-systems-in-jax","title":"Hamiltonian systems in Jax","text":"<p>In this ReCoDE exemplar, we introduce the basics of Hamiltonian dynamics and demonstrate how Python and JAX can be used to simulate and visualise systems. We go over the mathematical prerequisites and create a framework for solving Hamiltonian equations using the general dynamical systems solver in JAX. Finally, we demonstrate how we can implement simple harmonic oscillator and N-body systems, including visualisation code to plot various system simulated over time.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<p>By studying this exemplar you will be better able to:</p> <ul> <li>Use dynamical systems to model physical scenarios</li> <li>Use JAX to solve ODEs and perform linear algebra operations</li> <li>Visualise trajectories in 1D and 2D phase space</li> <li>Organise code in an an object-oriented way</li> </ul>"},{"location":"#estimated-duration","title":"Estimated Duration","text":"Task Time Reading 3 hours Practising 2 hours"},{"location":"#requirements","title":"Requirements","text":"<p>Undergraduate level calculus, linear algebra and a basic understanding of physics are required. Specific knowledge of Hamiltonian dynamics is not required, as we will introduce the necessary concepts in the course of this exemplar.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD-3-Clause license</p>"},{"location":"01-Introduction-to-Hamiltonian-Systems/","title":"Introduction to Hamiltonian Systems","text":"<p>Hamiltonian systems are a class of dynamical systems governed by the Hamiltonian function, which represents the total energy of the system\u2014kinetic and potential energy. These systems are a cornerstone of theoretical physics and are essential for understanding mechanics, astrophysics, and quantum mechanics.</p>"},{"location":"01-Introduction-to-Hamiltonian-Systems/#definition-of-a-hamiltonian-system","title":"Definition of a Hamiltonian System","text":"<p>A Hamiltonian system can be defined on a symplectic manifold, where the state of the system is described by coordinates . Here  are the generalized coordinates and  are the conjugate momenta.</p>"},{"location":"01-Introduction-to-Hamiltonian-Systems/#the-hamiltonian-function","title":"The Hamiltonian Function","text":"<p>The Hamiltonian  is a function, usually representing the total energy of the system:</p> <p> </p> <p>where  is the kinetic energy and  is the potential energy.</p>"},{"location":"01-Introduction-to-Hamiltonian-Systems/#properties","title":"Properties","text":"<ul> <li>Time Reversal Symmetry: If the system evolves forward in time, then reversing the direction of time will return the system to its initial state.</li> <li>Conservation of Energy: The total energy (Hamiltonian) is conserved if  does not explicitly depend on time.</li> </ul>"},{"location":"01-Introduction-to-Hamiltonian-Systems/#hamiltons-equations","title":"Hamilton's Equations","text":"<p>Hamilton's equations describe the time evolution of the system and are given by:</p> <p> </p> <p>These equations ensure that the flow of the system in phase space is symplectic, preserving the symplectic structure of the manifold.</p>"},{"location":"02-Installing-and-running-the-code/","title":"Installing and running the code","text":"In\u00a0[1]: Copied! <pre>import jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom hdynamics.dynamics import Nbody\n\nnbody = Nbody(dim=2, n_bodies=3)\n\ninitial_conditions = jnp.array([1, 2, 0, 0, 2, 1, -0.1, 0.1, 0.1, -0.2, 0.1, 0.2])\n\ntrajectory, t_span = nbody.generate_trajectory(initial_conditions, 0.01, 5000)\n\nfig, ax = plt.subplots()\n\nnbody.plot_trajectory(trajectory, t_span, ax)\n</pre> import jax.numpy as jnp import matplotlib.pyplot as plt  from hdynamics.dynamics import Nbody  nbody = Nbody(dim=2, n_bodies=3)  initial_conditions = jnp.array([1, 2, 0, 0, 2, 1, -0.1, 0.1, 0.1, -0.2, 0.1, 0.2])  trajectory, t_span = nbody.generate_trajectory(initial_conditions, 0.01, 5000)  fig, ax = plt.subplots()  nbody.plot_trajectory(trajectory, t_span, ax)"},{"location":"02-Installing-and-running-the-code/#installing-and-running-the-code","title":"Installing and running the code\u00b6","text":""},{"location":"02-Installing-and-running-the-code/#system-requirements","title":"System requirements\u00b6","text":"<p>The code requires Python and JAX (only CPU suffices, optionally with GPU support).</p> <p>If you are installing the code on a Windows machine, you will need to first install the Microsoft Visual C++ Build Tools. You can find the installer here. If prompted, select \"Desktop development with C++\" and install the required components.</p>"},{"location":"02-Installing-and-running-the-code/#installation","title":"Installation\u00b6","text":"<p>If you want to run the code in the project only, you can install the required packages from the <code>pyproject.toml</code> file using the following command:</p> <pre>pip install -e .\n</pre> <p>If you want to develop the code, you can install the required packages from the <code>pyproject.toml</code> file using the following command:</p> <pre>pip install -e .[dev]\n</pre> <p>We will discuss the individual components in the sections to come.</p>"},{"location":"02-Installing-and-running-the-code/#example-run","title":"Example run\u00b6","text":"<p>We'll cover the detail of what's going on in the code below later, but for now we can check everything is installed correctly by simulating and visualising the trajectory of an three-body system. If you get an error when running the code below, read the error carefully and try to fix it.</p>"},{"location":"03-Structure-of-the-code/","title":"Structure of the code","text":""},{"location":"03-Structure-of-the-code/#project-structure","title":"Project Structure","text":"<p>The structure of the code is as follows,</p> <pre><code>.\n\u251c\u2500\u2500 hdynamics\n\u2502   \u251c\u2500\u2500 hdynamics.py\n|   \u251c\u2500\u2500 dynamics\n|          \u251c\u2500\u2500 nbody.py\n|          \u251c\u2500\u2500 harmonic_oscillator.py\n</code></pre> <p>The <code>hdynamics.py</code> file contains the base class for dynamical systems, which defines the interface and some common functionality, including methods to solve the Hamiltonian equations of motion. The <code>dynamics</code> directory contains specific implementations of dynamical systems, such as the harmonic oscillator and N-body systems, which we will study as examples.</p> <p>We will discuss the individual components in the sections to come.</p>"},{"location":"03-Structure-of-the-code/#how-these-components-work-together","title":"How these components work together?","text":"<p>By organising the code in this way, we can put many features that are common to all dynamical systems in the base class in <code>hdynamics.py</code>, allowing them to be reused in the specific implementations in the <code>dynamics</code> directory. This means we can easily add new dynamical systems by creating new files in the <code>dynamics</code> directory that inherit from the base class in <code>hdynamics.py</code>. Each specific dynamical system can then implement its own Hamiltonian and any other system-specific functionality while still benefiting from the common features provided by the base class.</p>"},{"location":"03-Structure-of-the-code/#the-dynamics-class","title":"The <code>Dynamics</code> Class","text":"<p>The <code>Dynamics</code> class is defined in <code>hdynamics/hdynamics.py</code> and serves as the base class for all dynamical systems. It provides a common interface and some shared functionality for all dynamical systems, including methods to solve the Hamiltonian equations of motion. The key methods in the <code>Dynamics</code> class are:</p> <ul> <li>Constructor (<code>__init__</code>): Initializes the dynamics system with a specified number of dimensions. This is used to define the phase space of the system. Also creates a function <code>jac_h</code> which calculates the Jacobian of the Hamiltonian and stores it in the object. </li> <li><code>H</code>: This is the Hamiltonian of a dynamical system, and has to be specified for any dynamical system that is being implemented. This method is abstract, meaning it must be defined in any subclass that defines a dynamics system. </li> <li><code>symplectic_form</code>: Returns the symplectic form of the state of the system, which is used to compute the equations of motion. *<code>rate_of_change</code>: Returns a function that computes the rate of change of the state of the system, given the Hamiltonian. This is in a format suitable for use in an ODE solver.</li> <li><code>generate_trajectory</code>: Generates a trajectory of the system given an initial state, number of time steps and a length of timestep. This uses the function returned by the <code>rate_of_change</code> method to compute the evolution of the system over time.</li> <li><code>plot_trajectory</code>: Plots the trajectory of the system. This may be overridden in subclasses to define a way of plotting the trajectory that makes sense for that particular system.</li> </ul>"},{"location":"04-Simple_harmonic_oscillator_example/","title":"Simple Harmonic Oscillator","text":"In\u00a0[1]: Copied! <pre>from hdynamics.dynamics.harmonic_oscillator import HarmonicOscillator\n\nharmonic_oscillator = HarmonicOscillator(m=10, k=100)\n</pre> from hdynamics.dynamics.harmonic_oscillator import HarmonicOscillator  harmonic_oscillator = HarmonicOscillator(m=10, k=100) In\u00a0[2]: Copied! <pre>import jax.numpy as jnp\n\ninitial_condition = jnp.array([1.0, 0.0])\n\ntrajectory, t_span = harmonic_oscillator.generate_trajectory(initial_condition, 0.01, 1000)\n\nprint(f\"Trajectory shape: {trajectory.shape}\")\nprint(\"Trajectory:\", trajectory)\n\nprint(f\"Time span shape: {t_span.shape}\")\nprint(\"Time span:\", t_span)\n</pre> import jax.numpy as jnp  initial_condition = jnp.array([1.0, 0.0])  trajectory, t_span = harmonic_oscillator.generate_trajectory(initial_condition, 0.01, 1000)  print(f\"Trajectory shape: {trajectory.shape}\") print(\"Trajectory:\", trajectory)  print(f\"Time span shape: {t_span.shape}\") print(\"Time span:\", t_span) <pre>Trajectory shape: (1001, 2)\nTrajectory: [[ 1.          0.        ]\n [ 0.99950004 -0.9998335 ]\n [ 0.9980006  -1.9986669 ]\n ...\n [ 0.9896017  -4.5279784 ]\n [ 0.98457956 -5.51517   ]\n [ 0.97857374 -6.4967575 ]]\nTime span shape: (1001,)\nTime span: [ 0.         0.01       0.02      ...  9.9800005  9.990001  10.       ]\n</pre> In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(1, 1)\n\nharmonic_oscillator.plot_trajectory(trajectory, t_span, ax)\n</pre> import matplotlib.pyplot as plt  fig, ax = plt.subplots(1, 1)  harmonic_oscillator.plot_trajectory(trajectory, t_span, ax)"},{"location":"04-Simple_harmonic_oscillator_example/#simple-harmonic-oscillator","title":"Simple Harmonic Oscillator\u00b6","text":"<p>Next, we'll look at example of how to use the code to simulate and visaulise a simple dynamical system, the simple harmonic oscillator. This will provide an introduction to the framework and how to use it for simulating Hamiltonian systems. This will allow us to later delve into how the code actually achieves this, and how to extend it to more complex systems.</p> <p>In this chapter, we will discuss how to simulate and visualise a dynamical system. To do this, we will utilise a pre-existing implementation of the simple harmonic oscillator in <code>hdynamics/dynamics/harmonic_oscillator.py</code> to discuss how we can simulate and plot dynamical systems in our framework.</p>"},{"location":"04-Simple_harmonic_oscillator_example/#simple-harmonic-oscillator-hamiltonian","title":"Simple Harmonic Oscillator Hamiltonian\u00b6","text":"<p>For a mass $m$ attached to a spring with spring constant $k$, and ignoring damping, the Hamiltonian is:</p> <p>$$ H = \\frac{p^2}{2m} + \\frac{1}{2} k q^2 $$</p> <p>The resulting Hamilton's equations are:</p> <p>$$ \\dot{q} = \\frac{p}{m}\\\\ \\dot{p} = -kq  $$</p>"},{"location":"04-Simple_harmonic_oscillator_example/#the-harmonicoscillator-class","title":"The <code>HarmonicOscillator</code> Class\u00b6","text":"<p>The file <code>harmonic_oscillator.py</code> contains the class <code>HarmonicOscillator</code> that inherits from the abstract class <code>Dynamics</code> defined in <code>hdynamics/dynamics/hdynamics.py</code>. The constructor sets up the mass <code>m</code> and spring constant <code>k</code>, which are used to define the Hamiltonian of the system. It also calls the constructor of the superclass <code>Dynamics</code> with a <code>cdim</code> of 1, indicating that the system has one degree of freedom (position and momentum).</p> <p>This class implements the Hamiltonian method <code>H</code>, allowing the class to be instantiated and used to simulate the dynamics of the harmonic oscillator.</p> <p>It also contains the methods <code>plot_trajectory</code> which is designed to use the output of the <code>generate_trajectory</code> method of the <code>Dynamics</code> class to plot the position of the oscillator as a function of time.</p>"},{"location":"04-Simple_harmonic_oscillator_example/#example-simulation","title":"Example Simulation\u00b6","text":"<p>In the following code blocks we will define a harmonic oscillator, simulate the progression of the system over time and, plot the results.</p>"},{"location":"04-Simple_harmonic_oscillator_example/#creating-the-harmonic-oscillator","title":"Creating the Harmonic Oscillator\u00b6","text":"<p>To create the <code>HarmonicOscillator</code>, we must import it, then create it. We'll give it a mass of 10kg and a spring constant of 100N/m.</p>"},{"location":"04-Simple_harmonic_oscillator_example/#running-the-simulation","title":"Running the Simulation\u00b6","text":"<p>Next, we'll define initial condition of the system as a JAX array. We'll give the system an initial displacement of 1m and an initial momentum of 0kg m/s.</p> <p>Then, we will use the <code>generate_trajectory</code> method of the <code>HarmonicOscillator</code> class, passing the initial condition and defining a time step of 0.01 seconds and a total of 1000 steps. This returns both the trajectory of the system and the time span of the simulation in JAX arrays</p> <p><code>trajectory</code> has a shape of <code>(1001, 2)</code>. The first dimension relates to the time, and the second dimension relates to the position and momentum of the system. In this second dimension, the first column is the position, and the second column is the momentum. <code>time_span</code> has a shape of <code>(1001,)</code>, which contains the time values corresponding to each step in the trajectory. <code>trajectory</code> and <code>time_span</code> each have 1001 entries in their first dimension, corresponding to the initial condition and the 1000 steps taken in the simulation.</p>"},{"location":"04-Simple_harmonic_oscillator_example/#plotting-the-results","title":"Plotting the Results\u00b6","text":"<p>Finally, we will plot the trajectory of the harmonic oscillator using the <code>plot_trajectory</code> method of the <code>HarmonicOscillator</code> class. This will create a plot of the position of the oscillator as a function of time. This function takes the trajectory and time span as inputs, as well as a <code>matplotlib</code> axis object to plot on. The plot is a line graph, but also contains a point plotted at the end of the trajectory to emphasise the final position of the oscillator.</p>"},{"location":"05-N-body-example/","title":"N-Body Problem Example","text":"In\u00a0[1]: Copied! <pre>import jax.numpy as jnp\n\nfrom hdynamics.dynamics.nbody import Nbody\n\nnbody = Nbody(dim=2, n_bodies=3, masses=jnp.array([10.0, 2.0, 1.0]))\n</pre> import jax.numpy as jnp  from hdynamics.dynamics.nbody import Nbody  nbody = Nbody(dim=2, n_bodies=3, masses=jnp.array([10.0, 2.0, 1.0])) In\u00a0[2]: Copied! <pre>import jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\ninitial_conditions = jnp.array([1, 2, 0, 0, 0, -1, -0.1, 0.1, 0.1, -0.2, 0, 0.1])\n\ntrajectory, t_span = nbody.generate_trajectory(initial_conditions, 0.01, 2000)\n\nprint(f\"Trajectory shape: {trajectory.shape}\")\nprint(\"Trajectory:\", trajectory)\n\nprint(f\"Time span shape: {t_span.shape}\")\nprint(\"Time span:\", t_span)\n</pre> import jax.numpy as jnp import matplotlib.pyplot as plt  initial_conditions = jnp.array([1, 2, 0, 0, 0, -1, -0.1, 0.1, 0.1, -0.2, 0, 0.1])  trajectory, t_span = nbody.generate_trajectory(initial_conditions, 0.01, 2000)  print(f\"Trajectory shape: {trajectory.shape}\") print(\"Trajectory:\", trajectory)  print(f\"Time span shape: {t_span.shape}\") print(\"Time span:\", t_span) <pre>Trajectory shape: (2001, 12)\nTrajectory: [[ 1.0000000e+00  2.0000000e+00  0.0000000e+00 ... -2.0000000e-01\n   0.0000000e+00  1.0000000e-01]\n [ 9.9988943e-01  2.0000775e+00  5.4455642e-04 ... -1.8408032e-01\n   3.1639836e-03  1.2921949e-01]\n [ 9.9975765e-01  2.0001094e+00  1.1781018e-03 ... -1.6825616e-01\n   6.3422727e-03  1.5853254e-01]\n ...\n [ 1.0535572e+00  1.8014780e+00 -3.2761618e-01 ... -3.0015228e+00\n  -4.8184228e-01 -8.9709496e-01]\n [ 1.0560749e+00  1.8053695e+00 -3.3807236e-01 ... -2.9738660e+00\n  -3.7165257e-01 -9.0934932e-01]\n [ 1.0584670e+00  1.8092443e+00 -3.4844953e-01 ... -2.9466505e+00\n  -2.6258388e-01 -9.1992861e-01]]\nTime span shape: (2001,)\nTime span: [0.0000000e+00 1.0000001e-02 2.0000001e-02 ... 1.9980001e+01 1.9990002e+01\n 2.0000000e+01]\n</pre> In\u00a0[3]: Copied! <pre>fig, ax = plt.subplots(1, 1)\n\nnbody.plot_trajectory(trajectory, t_span, ax)\n</pre> fig, ax = plt.subplots(1, 1)  nbody.plot_trajectory(trajectory, t_span, ax) In\u00a0[4]: Copied! <pre>import jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nfrom hdynamics.dynamics.nbody import Nbody\n\n# Select the number of bodies\nn_bodies = 10\n\n# Create an instance of the Nbody class with the specified number of bodies\nnbody = Nbody(dim=2, n_bodies=n_bodies)\n\n# Create some random initial conditions\nkey = jax.random.PRNGKey(0)  \npositions = jax.random.uniform(key, shape=(n_bodies * 2,), minval=0.0, maxval=10.0)\nmomenta = jax.random.uniform(key, shape=(n_bodies * 2,), minval=-1.0, maxval=1.0)\ninitial_conditions = jnp.concatenate((positions, momenta))\n\n# Simulate the trajectory\ntrajectory, t_span = nbody.generate_trajectory(initial_conditions, 0.01, 2000)\n\n# Plot the trajectory\nfig, ax = plt.subplots(1, 1)\nnbody.plot_trajectory(trajectory, t_span, ax)\n</pre> import jax import jax.numpy as jnp import matplotlib.pyplot as plt  from hdynamics.dynamics.nbody import Nbody  # Select the number of bodies n_bodies = 10  # Create an instance of the Nbody class with the specified number of bodies nbody = Nbody(dim=2, n_bodies=n_bodies)  # Create some random initial conditions key = jax.random.PRNGKey(0)   positions = jax.random.uniform(key, shape=(n_bodies * 2,), minval=0.0, maxval=10.0) momenta = jax.random.uniform(key, shape=(n_bodies * 2,), minval=-1.0, maxval=1.0) initial_conditions = jnp.concatenate((positions, momenta))  # Simulate the trajectory trajectory, t_span = nbody.generate_trajectory(initial_conditions, 0.01, 2000)  # Plot the trajectory fig, ax = plt.subplots(1, 1) nbody.plot_trajectory(trajectory, t_span, ax)"},{"location":"05-N-body-example/#n-body-problem-example","title":"N-Body Problem Example\u00b6","text":"<p>This example demonstrates a more complex Hamiltonian system, the N-Body problem, using the <code>NBody</code> class from the file <code>hdynamics/dynamics/n_body.py</code>. The N-Body problem involves simulating the motion of multiple bodies under mutual gravitational attraction.</p>"},{"location":"05-N-body-example/#n-body-hamiltonian","title":"N-Body Hamiltonian\u00b6","text":"<p>One way the N-Body Hamiltonian is more complex than the simple harmonic oscillator is that it involves multiple bodies, and each has its own three-dimensional position and momentum vectors. We will use $(x_i, y_i, z_i)$ for the position coordinates and $(p_{x_i}, p_{y_i}, p_{z_i})$ for the momentum coordinates of the $i$-th body.</p> <p>We may define the kinetic energy of the system as:</p> <p>$T(p) = \\sum_{i=1}^{N} \\frac{p_{x_i}^2 + p_{y_i}^2 + p_{z_i}^2}{2m_i}$</p> <p>where $m_i$ is the mass of the $i$-th body.</p> <p>We can define the gravitational potential energy between two bodies as:</p> <p>$V(q) = -G \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} \\frac{m_i m_j}{\\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2}}$</p> <p>where $G$ is the gravitational constant.</p> <p>The Hamiltonian for the N-Body problem can then be expressed as:</p> <p>$H(q, p) = T(p) + V(q)$</p> <p>where $q$ is the vector of positions and $p$ is the vector of momenta for all bodies.</p>"},{"location":"05-N-body-example/#the-nbody-class","title":"The <code>NBody</code> Class\u00b6","text":"<p>The <code>NBody</code> class in the <code>hdynamics/dynamics/n_body.py</code> file encapsulates the N-Body problem. It allows you to define the number of bodies, their masses, and the gravitational constant. The class provides methods to compute the Hamiltonian, generate trajectories, and visualize the motion of the bodies.</p> <p>The constructor of the <code>NBody</code> class initializes the system with the number of dimensions the problem is to be solved in, the number of bodies, their masses, and the gravitational constant. Each body may have its own mass (in which case <code>masses</code> is an array) or the same mass (in which case <code>masses</code> is a scalar). Many of these parameters are optional, with default values provided. The constructor also calculates the instance variable <code>mass_outer_product</code> which is a 2D array, which at coordinates $(i, j)$ contains the product of the masses of the $i$-th and $j$-th bodies. This saves recomputing the mass products during the Hamiltonian calculations.</p> <p>The Hamiltonian is computed in the method <code>H</code> based on the positions and momenta of all bodies. The phase space vector for $N$ bodies is passed in the value $x$ and has the form:</p> <p>$ \\left(x_1, y_1, z_1, x_2, y_2, z_2, \\ldots, x_N, y_N, z_N, p_{x_1}, p_{y_1}, p_{z_1}, p_{x_2}, p_{y_2}, p_{z_2}, \\ldots, p_{x_N}, p_{y_N}, p_{z_N}\\right). $</p> <p>The Hamiltonian is computed. using several JAX operations to ensure efficient computation, including broadcasting and vectorized operations. This also reduces and simplifies the code, making it easier to read and maintain.</p> <p>The Hamiltonian also includes a parameter <code>eps</code> which is a small value, the square of which is added to the denominator in the potential energy calculation to avoid division by zero. This is particularly useful when two bodies are very close together, as it prevents numerical instability.</p> <p>The <code>plot_trajectory</code> method is currently defined to work only when two dimensions are used. It visualizes the trajectory of the bodies in a 2D plot, showing their positions over time using a line plot, with a different color for each body. The final positions of the bodies are marked with a dot.</p>"},{"location":"05-N-body-example/#example-simulation","title":"Example Simulation\u00b6","text":"<p>In the following code blocks, we will define a three-body system with different masses and initial conditions, generate a trajectory, and visualize the motion of the bodies.</p>"},{"location":"05-N-body-example/#creating-the-n-body-system","title":"Creating the N-Body System\u00b6","text":"<p>To create an instance of the <code>NBody</code> class, we need to import it then create it. We specify a 2-dimensional system with three bodies and give them different masses. We don't set the gravitational constant, so it will use the default value of $G = 1.0$. This is not physically realistic, but it simplifies the example.</p>"},{"location":"05-N-body-example/#running-the-simulation","title":"Running the Simulation\u00b6","text":"<p>Next, we define the initial conditions of the system. The first six entries represent the positions of the three bodies in 2D space, and the last six entries represent their momenta.</p> <p>We then generate a trajectory for the system over a specified time span. The positions and momenta of the bodies are stored in the <code>trajectory</code> variable, and the time points are stored in <code>t_span</code>. The trajectory is a 2D array where each row corresponds to a time point and each column corresponds to a position or momentum of a body.</p>"},{"location":"05-N-body-example/#plotting-the-results","title":"Plotting the Results\u00b6","text":"<p>Finally, we visualize the trajectory of the bodies in a 2D plot. Each body is represented by a line showing its path over time, and the final positions are marked with dots.</p>"},{"location":"05-N-body-example/#another-example","title":"Another Example\u00b6","text":"<p>Th code below shows how to create a system with 10 bodies, each with random initial positions and momenta. The initial conditions are generated using JAX's random number generation capabilities, ensuring reproducibility by setting a random seed.</p> <p>Try changing aspects of the system, such as the number of bodies, their masses, and the initial conditions to see how the dynamics change. You can also experiment with different time spans and step sizes for the trajectory generation. You should be able to observe that increasing the number of bodies significantly (try 100 bodies, for example) still leads to the system solving in a reasonably short time, thanks to the efficiency of JAX's vectorized operations.</p>"},{"location":"06-Defining-your-own-Hamiltonian-system/","title":"Defining your own Hamiltonian system","text":"<p>One of the goals of this ReCoDE is being able to implement a new Hamiltonian systems. In our framework, this can be done by creating a new dynamical system class that inherits from the <code>Dynamics</code> class defined in <code>dynamics.py</code>. You're invited to follow along and implement your own Hamiltonian system as an exercise.</p>"},{"location":"06-Defining-your-own-Hamiltonian-system/#1-creating-a-new-dynamical-systems-file","title":"1. Creating a new dynamical systems file","text":"<p>We start by creating a new file for our dynamical system <code>hdynamics/dynamics/[name].py</code></p>"},{"location":"06-Defining-your-own-Hamiltonian-system/#2-inherit-dynamics-class","title":"2. Inherit Dynamics class","text":"<p>We then create a new class by inheriting from <code>hdynamics.dynamics.Dynamics</code> class. The template below shows the class structure, but without the complete method implementations:</p> <pre><code>import jax.numpy as jnp\n\nfrom hdynamics.dynamics import Dynamics\n\nclass MyHamiltonianSystem(Dynamics):\n    \"\"\" My new class that implements a dynamical system. \"\"\"\n    def __init__(self, dim):\n        cdim = dim\n        super().__init__(cdim)\n\n    def H(self, x):\n        pass\n\n    def plot_trajectory(self, trajectory, t_span, ax):\n        \"\"\"Plot trajectory within specified t_span range.\"\"\"\n        pass\n</code></pre>"},{"location":"06-Defining-your-own-Hamiltonian-system/#3-define-the-hamiltonian-of-the-system-in-selfhx","title":"3. Define the Hamiltonian of the system in <code>self.H(x)</code>","text":"<p>To implement the Hamiltonian, we simply define it as a function in <code>self.H(x)</code>. This is the only necessary thing to define for our dynamical system to be valid.</p> <p>If you would like a suggestion of a simple Hamiltonian, you could use the example of a body free-falling in a gravitational field, which is defined as:</p> <p> </p> <p>where  is the kinetic energy,  is the potential energy,  is the Hamiltonian,  is the mass of the body,  is its vertical velocity,  is the gravitational acceleration, and  is the vertical position of the body.</p>"},{"location":"06-Defining-your-own-Hamiltonian-system/#4-optional-define-plotting-function","title":"4 (optional). Define plotting function","text":"<p>Optionally, we can also create code that plots trajectories <code>self.plot_trajectory(self, trajectory, t_span, ax)</code> and phase space <code>self.plot_H(self, ax)</code>. Here, <code>ax</code> is a Matplotlib Axes object.</p> <p>If you chose to implement the example of a body free-falling in the gravitational field, you could plot the vertical position of the body over time, or the speed of the bdy over time (remember speed can be defined in terms of momentum as ).</p>"},{"location":"06-Defining-your-own-Hamiltonian-system/#5-run-the-code","title":"5. Run the Code","text":"<p>To run the code, you could import the class into a Jupyter notebook or Python script and create an instance of the class. Then, you can call the methods to perform the simulation and plot the result. For example:</p> <pre><code>from hdynamics.dynamics import MyHamiltonianSystem\n\n# Create an instance of the Hamiltonian system\nsystem = MyHamiltonianSystem()\n\n# Define initial conditions and time span\ninitial_conditions = jnp.array([1.0, 0.0])  # Example initial conditions\ntime_span = jnp.linspace(0, 10, 100)  # Example time span\n\n# Simulate the system\ntrajectory, t_span = system.simulate(initial_conditions, time_span)\n\n# Plot the trajectory\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots()\n\nsystem.plot_trajectory(trajectory, t_span, ax)\nplt.show()\n</code></pre>"},{"location":"07-Object-Oriented-design/","title":"Object-Oriented Design","text":"<p>In this notebook, we'll explore the object-oriented design of the Hamiltonian systems code base, including explaining the design philosophy.</p>"},{"location":"07-Object-Oriented-design/#inheritance","title":"Inheritance","text":"<p>The design of the code makes use of the fact that there are many different dynamical systems that can be described by Hamiltonian mechanics. By defining <code>Dynamics</code> as a base class, we can include components that are common to all dynamical systems in this class. This includes some more complex methods such as <code>generate_trajectory</code>, which indirectly uses the Hamiltonian method <code>H</code> to generate trajectories.</p> <p>This makes reusing the entire code of this class easier, as we can simply inherit from this class when implementing a new dynamical system. The child class can then implement the Hamiltonian and any other system-specific functionality while still benefiting from the common features provided by the base class.</p>"},{"location":"07-Object-Oriented-design/#abstract-class","title":"Abstract Class","text":"<p>By making <code>Dynamics</code> an abstract class, we prevent it from being instantiated directly. This is useful because <code>Dynamics</code> is not a specific dynamical system, but rather a blueprint for any dynamical system. The abstract class enforces that any child class must implement the Hamiltonian method <code>H</code>, which is essential for defining the dynamics of the system. <code>H</code> is a good example of an abstract method as it is relied upon by other methods in the <code>Dynamics</code> class, such as <code>generate_trajectory</code>.</p>"},{"location":"07-Object-Oriented-design/#optional-methods","title":"Optional Methods","text":"<p>The child classes can optionally define the method <code>plot_trajectory</code>. This method is not abstract, meaning that it is not required for the child class to implement it. If the method is called in a child class that does not implement it, it will raise a <code>NotImplementedError</code>. This allows for flexibility in the design, as not all dynamical systems may require a specific plotting method.</p>"},{"location":"07-Object-Oriented-design/#caching","title":"Caching","text":"<p>In the different classes, some calculations are performed in the constructor and stored in instance variables. This is done to avoid recalculating these values repeatedly as the simulation progresses. For example, the <code>cdim</code> variable is calculated in the constructor and stored as an instance variable, so it can be reused in other methods without recalculating it each time.</p> <p>For example, in the <code>Dynamics</code> class, the <code>pdim</code> variable (representing the length of the phase vector) is calculated in the constructor and stored as an instance variable. The JAX function <code>jac_h</code> is also cached in the constructor to avoid recalculating it each time it is needed. This caching mechanism improves performance by reducing redundant calculations during the simulation. In the <code>NBody</code> class, the <code>mass_outer_product</code> variables is also calculated and cached in the constructor. This is possible because the mass of the bodies does not change during the simulation, so  the product of the masses can be calculated once in advance and reused throughout the simulation.</p>"},{"location":"08-Using-JAX-to-solve-the-equations/","title":"Use of JAX","text":"<p>JAX is a powerful library for numerical computing in Python, which allows us to efficiently and conveniently compute gradients and perform automatic differentiation. In the context of Hamiltonian dynamics, JAX can be used to compute the gradients of the Hamiltonian function, which is essential for integrating the equations of motion.</p>"},{"location":"08-Using-JAX-to-solve-the-equations/#the-implementation-of-jax-functions","title":"The Implementation of JAX Functions","text":"<p>Unlike standard Python functions, JAX functions, especially those created using transformations like <code>jax.grad</code> (used in the <code>jac_h</code> attribute) and <code>jax.jit</code>, are executed in a special way. When you use these transformations, JAX traces your code to build a computation graph, which it can then optimize and compile for fast execution on CPUs, GPUs, or TPUs. The code called by these functions (such as within the method <code>H</code>) is not always run line-by-line in the normal Python interpreter. Instead, JAX focuses on pure, functional-style code that operates on arrays. This approach enables automatic differentiation and high performance.</p> <p>JAX's just-in-time (JIT) compilation, enabled by wrapping functions with <code>jax.jit</code>, further accelerates code by compiling Python functions to efficient machine code the first time they are called. In this codebase, both the gradient of the Hamiltonian (<code>jac_h</code>) and the function that computes the rate of change of the system are JIT-compiled for efficiency.</p> <p>In our case, the actual execution of the Hamiltonian method <code>H</code> is transformed into a JAX-compatible function that can be differentiated and optimized. The execution of this function is triggered when <code>jax.experimental.ode</code> is called in <code>generate_trajectory</code>. This means that the code inside <code>H</code> is not executed in the usual Python way, but rather as part of a JAX computation graph.</p> <p>One side effect is that print statements may not behave as expected as the code is not executed by the normal Python interpreter. It also means that debugging and control flow can feel different from regular Python. For debugging inside JAX-transformed functions, you should use <code>jax.debug.print()</code> rather than the standard <code>print()</code> function.</p> <p>Note that because JAX may trace and compile your functions, code inside these functions can be executed more than once (e.g., during tracing and then during actual computation), and JAX expects functions to be pure (no side effects). This is another reason why debugging output may not appear as expected.</p>"},{"location":"08-Using-JAX-to-solve-the-equations/#attributes-of-dynamics-class","title":"Attributes of <code>Dynamics</code> Class","text":"<p>In the <code>Dynamics</code> class, we define the interface of the Hamiltonian method <code>H</code>. When defined in a subclass, this will be a normal method that can be called to compute the Hamiltonian of a state of a dynamical system. </p> <p>In the constructor of the <code>Dynamics</code> class we define the attribute <code>jac_h</code>, which is a JAX function that computes the Jacobian of the Hamiltonian with respect to the phase space variables. This is done using <code>jax.grad(H)</code>, where <code>H</code> is the Hamiltonian method defined in the subclass. It can be called with a phase space vector <code>x</code> to compute the Jacobian of the Hamiltonian at that point in phase space, such as:</p> <pre><code>grad_H = system.jac_h(phase_vector)\n</code></pre> <p>Although it is called in a way which looks like a method, it is actually not a method, but instead a JAX function stored as an attribute of the <code>Dynamics</code> class.</p> <p>The method <code>get_rate_of_change</code> does not actually calculate a rate of change, but instead returns a method (referred to as <code>grad_x</code> within the method) that calculates the rate of change of the phase space variables given a phase space vector <code>x</code>. It does this using the static method <code>symplectic_form</code> and the JAX function <code>jac_h</code>.</p> <p><code>generate_trajectory</code> is a method that uses the JAX ODE solver to integrate the equations of motion for the dynamical system. It uses <code>get_rate_of_change</code> to obtain a function that computes the rate of change of the phase space variables, which is then passed to the JAX ODE solver <code>jax.experimental.odeint</code>. The ODE solver internally builds a computation graph that allows it to efficiently compute the trajectory of the system over time, and then executes this graph to obtain the trajectory.</p>"},{"location":"08-Using-JAX-to-solve-the-equations/#performance-considerations","title":"Performance Considerations","text":"<p>JAX is designed for high performance, especially when working with large arrays and complex computations. The use of JAX's automatic differentiation and just-in-time compilation allows for efficient execution of the Hamiltonian dynamics simulations. However, the tracing and compilation process introduces some extra overhead compared to other methods such as the <code>odeint</code> function from SciPy. This means that the first time you call a JAX function, it may take longer to execute due to the compilation step. Subsequent calls will be faster as the computation graph is reused.</p> <p>As a result, this JAX implementation may be slow for small, simple, one-off computations (including many of the examples in this exemplar), but it may be much faster for larger, more complex simulations where the overhead of tracing and compiling is amortized over many computations.</p>"},{"location":"09-Using-matplotlib-to-produce-outputs/","title":"Using Matplotlib","text":"<p>This exemplar uses Matplotlib to produce outputs in the <code>plot_trajectories</code> methods of the <code>HarmonicOscillator</code> and <code>NBody</code> classes. Most of this is fairly standard, but there are a few things to note.</p>"},{"location":"09-Using-matplotlib-to-produce-outputs/#passing-an-axes-object-as-an-argument","title":"Passing an Axes Object as an Argument","text":"<p>Both <code>plot_trajectory</code> method taken an <code>Axes</code> object as an argument. This is a common pattern in Matplotlib, where you create a figure and axes object, and then pass the axes object to the plotting function. This allows the code which calls the functions to control the figure the axes appear in, and other context in which the axes are placed. In the notebooks showcasing the simple harmonic oscillator and N-body systems, we create a figure and axes object using <code>plt.subplots()</code> and then pass the axes object to the <code>plot_trajectory</code> method.</p>"},{"location":"09-Using-matplotlib-to-produce-outputs/#synchronising-colours","title":"Synchronising Colours","text":"<p>In the <code>plot_trajectory</code> methods in the <code>HarmonicOscillator</code> and <code>NBody</code> classes, there are lines that show the trajectory over time, and a point at the end of the trajectory. In order to ensure that the point at the end of the trajectory has the same colour as the line, we save a reference to the value returned from the call to <code>ax.plot()</code> in a variable called <code>line</code>. This is a list of line objects, and we can access the first element of this list to get the line object itself. We then use the <code>get_color()</code> method of the line object to get the colour of the line, which we then use to set the colour of the point at the end of the trajectory. This ensures that the point at the end of the trajectory has the same colour as the line.</p>"}]}